Kaldi používateľská príručka: popis zdrojových kódov

1. Argument príkazového riadku

Pre zápis
"-" standard output. 
"b" (binary) means write in binary mode (currently unnecessary as it's always the default). 
"t" (text) means write in text mode. 
"f" (flush) means flush the stream after each write operation.
"nf" (no-flush) means don't flush the stream after each write operation (would currently be pointless, but calling code can change the default). 
"p" means permissive mode, which affects "scp:" wspecifiers where the scp file is missing some entries: the "p" option will cause it to silently not write anything for these files, and report no error. 
Pre čítanie
"-" standard input. 
"o" (once) is the user's way of asserting to the RandomAccessTableReader code that each key will be queried only once. This stops it from having to keep already-read objects in memory just in case they are needed again. 
"p" (permissive) instructs the code to ignore errors and just provide what data it can; invalid data is treated as not existing. In scp files, this means that a query to HasKey() forces the load of the corresponding file, so the code can know to return false if the file is corrupt. In archives, this option stops exceptions from being raised if the archive is corrupted or truncated (it will just stop reading at that point). 
"s" (sorted) instructs the code that the keys in an archive being read are in sorted string order. For RandomAccessTableReader, this means that when HasKey() is called for some key not in the archive, it can return false as soon as it encounters a "higher" key; it won't have to read till the end. 
"cs" (called-sorted) instructs the code that the calls to HasKey() and Value() will be in sorted string order. Thus, if one of these functions is called for some string, the reading code can discard the objects for lower-numbered keys. This saves memory. In effect, "cs" represents the user's assertion that some other archive that the program may be iterating over, is itself sorted. 

2.Generovanie MFCC

compute-mfcc-feats scp:waw.scp ark,t,scp:mfcc.ark,mfcc.scp
rspecifier- scp:waw.scp
wspecifier – ark,t,scp:mfcc.ark,mfcc.scp

scp – “script file”: obsahuje cestu k jednotlivým nahrávkam a tiež miesto čítania z archívu fseek() na pozíciu 23 a 10753 (č. riadkov v matici)

speaker000-par001s0030 /home/vavrek/kaldi debug/egs/parlament/s5/data/mfcc_train/raw_mfcc_train.1.ark:23
speaker001-par004s0011 /home/vavrek/kaldi-debug/egs/parlament/s5/data/mfcc_train/raw_mfcc_train.1.ark:10753

ark – “archive”: archív v textovom móde ak je uvedený argument t, implicitne nastavené na binárny mód

speaker000-par001s0030  [
  14.10826 1.689854 2.631049 1.615903 -7.061874 -5.217402 -14.75945 -9.99846 1.162343 1.751029 14.06324 2.120507 -2.416143 
  13.88153 1.778843 3.930727 3.530488 -0.6994777 1.746091 -13.97855 -8.412409 -8.900908 -4.976469 3.917657 -8.219433 -5.273274 
  13.70978 -1.245511 -0.3259394 2.909337 -9.779212 -3.678674 -5.82101 -4.553367 -6.346621 -0.783889 -10.18138 -3.589136 -3.022692 
  13.12408 -8.44072 -2.119956 5.159504 -14.26084 -0.8716287 -8.602939 -11.09097 -13.45098 -9.396022 -10.84965 -1.33166 -0.8408574 
  13.51634 -12.8888 0.5638425 14.02303 -15.8473 5.804669 -6.862232 -22.34762 -1.288737 6.291987 -11.12249 -1.468823 -11.78562 ]
speaker001-par004s0011  [
  12.06458 -2.333197 7.109605 -2.344448 -4.66145 4.072924 -11.30209 -8.290196 -9.794406 -14.6836 -4.018123 0.3603373 -4.332555 
  12.2433 -2.650045 6.044868 -4.017526 -9.199212 -7.695528 -3.449128 -5.392704 -10.16296 -0.2477354 -8.551126 2.979215 0.1277829 
  12.51178 -3.844823 4.488879 -1.087927 -0.1987881 2.168946 -6.737176 -2.354375 -10.25441 5.24179 9.674825 8.508047 9.885266 
  12.65401 -0.9313743 8.635545 5.32293 2.081174 -2.121343 -9.746995 -16.85775 -15.4945 0.7855694 5.374227 -0.01060295 1.169994 
  12.60024 -2.222284 9.831885 -2.339098 -2.343368 -4.274204 -12.12814 -12.39186 -10.77977 -2.046569 10.29807 7.976638 2.468218 ]


3.Výpočet CMVN
compute-cmvn-stats --spk2utt=ark:data/train/spk2utt scp:mfcc.scp ark,t,scp:cmvn.ark,cmvn.scp

- v steps/make_mfcc.sh je použitá voľba --use-energy=false  

-realizuje výpočet globálnej strednej hodnoty a variancie pre každého rozprávača, teda dvojicu speaker- utterance (speaker000-par001s0030)
-ak je zadaná voľba –-spk2utt tak výpošet mean a var sa realizuje pre daného rečníka a všetky nahrávky ktoré mu prislúchajjú speaker – utterance1 utterance2      
(speaker000-par001s0030 par001s0031)
-1. riadok: hodnoty reprezentujú sumu hodnôt prvkov MFCC matice pre každý stĺpec (1-13) sum(MFCC(:,:)), 14-ty prvok definuje počet riadkov MFCC matice 
-2.riadok: druhá mocnina  hodnôt prvkov MFCC matice pre každý stĺpec (1-13) sum(MFCC(:,:).^2)

speaker000  [
  14874.82 4127.407 150.2739 3767.68 -2556.519 -12144.36 -7377.112 -15112.51 -5437.99 -8100.915 -6496.962 -5440.803 -5942.836 814 
  276232.1 82202.37 123486 211474.4 76469.22 345183.5 197318.6 421583.8 154372.6 164476.3 156354.3 168044.1 135945.8 0 ]
speaker001  [
  4998.798 2292.822 -370.6259 1696.672 -897.5402 -443.0184 -28.96256 -3896.802 -817.6271 -2986.011 -1319.419 1772.494 -724.1689 304 
  84542.13 72147.26 27536.28 22233.31 28293.79 21432.88 52587.16 87120.75 47442.33 63314.53 50690.28 33605.21 38872.65 0 ]


4. Príprava jazykového modela a slovníka do kaldi formátu





5. Trénovanie monofónového GMM modelu (flat start)
steps/train_mono.sh --nj 1 --cmd run.pl data/train data/lang_train exp/mono;

-najprv sa spustí gmm-init-mono

gmm-init-mono --shared-phones=data/lang_train/phones/sets.int '--train-feats=ark,s,cs:apply-cmvn  --utt2spk=ark:data/train/split1/1/utt2spk scp:data/train/split1/1/cmvn.scp scp:data/train/split1/1/feats.scp ark:- | add-deltas ark:- ark:- | subset-feats --n=10 ark:- ark:-|' data/lang_train/topo 39 exp/mono/0.mdl exp/mono/tree 

apply-cmvn --utt2spk=ark:data/train/split1/1/utt2spk scp:data/train/split1/1/cmvn.scp scp:data/train/split1/1/feats.scp ark:- 
-aplikuje CMVN na všetky utt

add-deltas ark:- ark:- 
-pridá delda a delta-delta koeficienty

subset-feats --n=10 ark:- ark:- 
-kopíruje prvých 10 utt (MFCC matíc)

 	
-výpočet glob_inv_var a glob_mean (globálna hodnoda strednej hodnoty pre všetky matice MFCC a inverznej variancie so škálovaním 1/počet riadkov všetkých matíc: var_stats.Scale(1.0/count); mean_stats.Scale(1.0/count))

-nacitanie topológie zo súboru data/lang_train/topo
-príklad topológie
 <Topology>
 <TopologyEntry>
 <ForPhones> 1 2 3 4 5 6 7 8 </ForPhones>
 <State> 0 <PdfClass> 0
 <Transition> 0 0.5
 <Transition> 1 0.5
 </State> 
 <State> 1 <PdfClass> 1 
 <Transition> 1 0.5
 <Transition> 2 0.5
 </State>  
 <State> 2 <PdfClass> 2
 <Transition> 2 0.5
 <Transition> 3 0.5
 </State>   
 <State> 3
 </State>   
 </TopologyEntry>
 </Topology>

-vytvorí sa objekt triedy HmmTopology : this is the way the user specifies to the toolkit the topology of the HMMs the phones

HmmTopology topo;

extrahovanie foném typu int
const std::vector<int32> &phones = topo.GetPhones();	
phone[0]: 1
phone[1]: 2
…
phone[51]: 52

priradenie počtu pdf tried pre každú fonému
phone2num_pdf_classes[phones[i]] = topo.NumPdfClasses(phones[i]);
phone2num[1]: 5
phone2num[2]: 5
phone2num[3]: 5
phone2num[4]: 5
phone2num[5]: 5
phone2num[6]: 5
phone2num[7]: 3
...
phone2num[52]: 3
If the pdf-class for some HMM state is set to the constant kNoPdf = -1, then the HMM state is nonemitting (it has no associated pdf).
The set of pdf-classes for a particular prototype HMM is expected to start from zero and be contiguous (e.g. 0, 1, 2).
5 different pdf-ids. 





Vytvorenie stromu:

ContextDependency *ctx_dep = NULL;

-vytvorí sa smerník na objekt triedy ContexDependency

-následne načítanie phone listu:

ReadSharedPhonesList(shared_phones_rxfilename, &shared_phones);

shared_phones:[0][0]: 1
shared_phones:[1][0]: 2
shared_phones:[2][0]: 3
…
shared_phones:[51][0]: 52

-inicializácia:
 num_leaves = 0, P = 0, N = 1;


N is context size
P = position of central phone (must be 0)


typedef std::vector<std::pair<EventKeyType,EventValueType> > EventType; 

EvantMap trieda pre klastrovanie stromu:

EventMap *pdf_map = GetStubMap(P, phone_sets, phone2num_pdf_classes, share_roots, &num_leaves);

EventMap := ConstantEventMap | SplitEventMap | TableEventMap | "NULL"
ConstantEventMap := "CE" <numeric pdf-id>
SplitEventMap := "SE" <key-to-split-on> "[" yes-value-list "]" "{" EventMap EventMap "}"
TableEventMap := "TE" <key-to-split-on> <table-size> "(" EventMapList ")"

ontextDependency 1 0 ToPdf TE 0 53 ( NULL TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) 
TE -1 5 ( CE 5 CE 6 CE 7 CE 8 CE 9 ) 
TE -1 5 ( CE 10 CE 11 CE 12 CE 13 CE 14 ) 
TE -1 5 ( CE 15 CE 16 CE 17 CE 18 CE 19 ) 
TE -1 5 ( CE 20 CE 21 CE 22 CE 23 CE 24 ) 
TE -1 5 ( CE 25 CE 26 CE 27 CE 28 CE 29 ) 
TE -1 3 ( CE 30 CE 31 CE 32 ) 
…
TE -1 3 ( CE 165 CE 166 CE 167 ) 
) 
EndContextDependency 

“TE 0 53” the key "0" is the phone-position of zero which represents the central (and only) phone since the context width (N) is 1. The number of entries in the table is 53 (in this case, the number of phones plus one). The first EventMap in the table (index zero) is NULL, because there is no phone with index zero.

"TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )" represents splitting with a TableEventMap on the pdf-class "-1" (effectively, the HMM-position), and returning values 0 through 4. The values represent the five pdf-ids for the silence and noise phones SIL, NSN and SPN; in our setup, the pdfs are shared between these three non-speech phones (only the transition matrix is specific to each non-speech phone). Note: we have a 5-state rather than 3-state HMM for these phones, hence 
Inicializácia GMM

-pomocou objektov tried AmDiagGmm a DiagGmm

AmDiagGmm am_gmm;
DiagGmm gmm;
    gmm.Resize(1, dim);
    {  // Initialize the gmm.
-alokácia a inicializácia inv_var a mu pomocou vektorov globálnej strednej hodnoty a variancie

      Matrix<BaseFloat> inv_var(1, dim);
      inv_var.Row(0).CopyFromVec(glob_inv_var);
inv_var:  [ 0.012317 0.00639358 0.00683943 0.00435026 0.00755167 0.0054663 0.00601155 0.00632084 0.00547995 0.00777593 0.00802094 0.00596493 0.00901718 0.279607 0.147797 0.136844 0.100969 0.116538 0.0898784 0.107806 0.0918681 0.0799345 0.112086 0.111274 0.0945501 0.145626 1.91753 0.983717 0.865011 0.655235 0.670666 0.509123 0.605864 0.491665 0.443386 0.605588 0.60839 0.508616 0.787544 ]

	Matrix<BaseFloat> mu(1, dim);
      mu.Row(0).CopyFromVec(glob_mean);
mu:  [ -1.93785e-08 5.20363e-08 -2.03184e-09 7.16105e-08 2.64139e-08 -4.16317e-08 3.88169e-08 2.87818e-09 -4.31438e-08 -1.3298e-08 3.13304e-08 3.15461e-08 4.40389e-08 -0.000437066 0.0078276 0.00987549 0.00740368 0.00860737 -0.0005549 0.00432395 -0.00553214 -0.0123082 0.000648228 -0.00265132 0.000575265 -0.00190697 -0.000401413 0.0010554 -0.000208291 -0.00142547 0.00084816 0.00133549 0.000180131 0.00106665 -0.000806734 -0.00148568 0.000448892 -0.00038275 -0.000418162 ]
-alokácia a inicializácia váh weights na hodnotu 1

	Vector<BaseFloat> weights(1);
      weights.Set(1.0);

      gmm.SetInvVarsAndMeans(inv_var, mu);
-nainicializuje strednú hodnotu a varianciu pre všetky PDFs
inv_var[i] * mu[i]
<MEANS_INVVARS>  [
  -2.386852e-10 3.326984e-10 -1.389661e-11 3.115239e-10 1.994691e-10 -2.275714e-10 2.333496e-10 1.819253e-11 -2.364259e-10 -1.034045e-10 2.512991e-10 1.8817e-10 3.971067e-10 -0.0001222068 0.001156897 0.001351406 0.0007475433 0.001003082 -4.987351e-05 0.0004661482 -0.0005082276 -0.0009838532 7.265755e-05 -0.0002950226 5.439135e-05 -0.0002777049 -0.0007697208 0.001038217 -0.0001801743 -0.0009340189 0.0005688321 0.0006799264 0.0001091349 0.0005244361 -0.0003576949 -0.000899711 0.0002731017 -0.0001946728 -0.0003293207 ]

      gmm.SetWeights(weights);
      gmm.ComputeGconsts();
    }













6. Trénovanie trifónového GMM/HMM modelu

