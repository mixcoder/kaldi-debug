Kaldi používateľská príručka: popis zdrojových kódov

1. Argument príkazového riadku

Pre zápis
"-" standard output. 
"b" (binary) means write in binary mode (currently unnecessary as it's always the default). 
"t" (text) means write in text mode. 
"f" (flush) means flush the stream after each write operation.
"nf" (no-flush) means don't flush the stream after each write operation (would currently be pointless, but calling code can change the default). 
"p" means permissive mode, which affects "scp:" wspecifiers where the scp file is missing some entries: the "p" option will cause it to silently not write anything for these files, and report no error. 
Pre čítanie
"-" standard input. 
"o" (once) is the user's way of asserting to the RandomAccessTableReader code that each key will be queried only once. This stops it from having to keep already-read objects in memory just in case they are needed again. 
"p" (permissive) instructs the code to ignore errors and just provide what data it can; invalid data is treated as not existing. In scp files, this means that a query to HasKey() forces the load of the corresponding file, so the code can know to return false if the file is corrupt. In archives, this option stops exceptions from being raised if the archive is corrupted or truncated (it will just stop reading at that point). 
"s" (sorted) instructs the code that the keys in an archive being read are in sorted string order. For RandomAccessTableReader, this means that when HasKey() is called for some key not in the archive, it can return false as soon as it encounters a "higher" key; it won't have to read till the end. 
"cs" (called-sorted) instructs the code that the calls to HasKey() and Value() will be in sorted string order. Thus, if one of these functions is called for some string, the reading code can discard the objects for lower-numbered keys. This saves memory. In effect, "cs" represents the user's assertion that some other archive that the program may be iterating over, is itself sorted. 

2.Generovanie MFCC

compute-mfcc-feats scp:waw.scp ark,t,scp:mfcc.ark,mfcc.scp
rspecifier- scp:waw.scp
wspecifier – ark,t,scp:mfcc.ark,mfcc.scp

scp – “script file”: obsahuje cestu k jednotlivým nahrávkam a tiež miesto čítania z archívu fseek() na pozíciu 23 a 10753 (č. riadkov v matici)

speaker000-par001s0030 /home/vavrek/kaldi debug/egs/parlament/s5/data/mfcc_train/raw_mfcc_train.1.ark:23
speaker001-par004s0011 /home/vavrek/kaldi-debug/egs/parlament/s5/data/mfcc_train/raw_mfcc_train.1.ark:10753

ark – “archive”: archív v textovom móde ak je uvedený argument t, implicitne nastavené na binárny mód

speaker000-par001s0030  [
  14.10826 1.689854 2.631049 1.615903 -7.061874 -5.217402 -14.75945 -9.99846 1.162343 1.751029 14.06324 2.120507 -2.416143 
  13.88153 1.778843 3.930727 3.530488 -0.6994777 1.746091 -13.97855 -8.412409 -8.900908 -4.976469 3.917657 -8.219433 -5.273274 
  13.70978 -1.245511 -0.3259394 2.909337 -9.779212 -3.678674 -5.82101 -4.553367 -6.346621 -0.783889 -10.18138 -3.589136 -3.022692 
  13.12408 -8.44072 -2.119956 5.159504 -14.26084 -0.8716287 -8.602939 -11.09097 -13.45098 -9.396022 -10.84965 -1.33166 -0.8408574 
  13.51634 -12.8888 0.5638425 14.02303 -15.8473 5.804669 -6.862232 -22.34762 -1.288737 6.291987 -11.12249 -1.468823 -11.78562 ]
speaker001-par004s0011  [
  12.06458 -2.333197 7.109605 -2.344448 -4.66145 4.072924 -11.30209 -8.290196 -9.794406 -14.6836 -4.018123 0.3603373 -4.332555 
  12.2433 -2.650045 6.044868 -4.017526 -9.199212 -7.695528 -3.449128 -5.392704 -10.16296 -0.2477354 -8.551126 2.979215 0.1277829 
  12.51178 -3.844823 4.488879 -1.087927 -0.1987881 2.168946 -6.737176 -2.354375 -10.25441 5.24179 9.674825 8.508047 9.885266 
  12.65401 -0.9313743 8.635545 5.32293 2.081174 -2.121343 -9.746995 -16.85775 -15.4945 0.7855694 5.374227 -0.01060295 1.169994 
  12.60024 -2.222284 9.831885 -2.339098 -2.343368 -4.274204 -12.12814 -12.39186 -10.77977 -2.046569 10.29807 7.976638 2.468218 ]


3.Výpočet CMVN
compute-cmvn-stats --spk2utt=ark:data/train/spk2utt scp:mfcc.scp ark,t,scp:cmvn.ark,cmvn.scp

- v steps/make_mfcc.sh je použitá voľba --use-energy=false  

-realizuje výpočet globálnej strednej hodnoty a variancie pre každého rozprávača, teda dvojicu speaker- utterance (speaker000-par001s0030)
-ak je zadaná voľba –-spk2utt tak výpošet mean a var sa realizuje pre daného rečníka a všetky nahrávky ktoré mu prislúchajjú speaker – utterance1 utterance2      
(speaker000-par001s0030 par001s0031)
-1. riadok: hodnoty reprezentujú sumu hodnôt prvkov MFCC matice pre každý stĺpec (1-13) sum(MFCC(:,:)), 14-ty prvok definuje počet riadkov MFCC matice 
-2.riadok: druhá mocnina  hodnôt prvkov MFCC matice pre každý stĺpec (1-13) sum(MFCC(:,:).^2)

speaker000  [
  14874.82 4127.407 150.2739 3767.68 -2556.519 -12144.36 -7377.112 -15112.51 -5437.99 -8100.915 -6496.962 -5440.803 -5942.836 814 
  276232.1 82202.37 123486 211474.4 76469.22 345183.5 197318.6 421583.8 154372.6 164476.3 156354.3 168044.1 135945.8 0 ]
speaker001  [
  4998.798 2292.822 -370.6259 1696.672 -897.5402 -443.0184 -28.96256 -3896.802 -817.6271 -2986.011 -1319.419 1772.494 -724.1689 304 
  84542.13 72147.26 27536.28 22233.31 28293.79 21432.88 52587.16 87120.75 47442.33 63314.53 50690.28 33605.21 38872.65 0 ]


4. Príprava jazykového modela a slovníka do kaldi formátu





5. Trénovanie monofónového GMM modelu (flat start)
steps/train_mono.sh --nj 1 --cmd run.pl data/train data/lang_train exp/mono;

####################################################################
-najprv sa spustí gmm-init-mono
####################################################################

gmm-init-mono --shared-phones=data/lang_train/phones/sets.int '--train-feats=ark,s,cs:apply-cmvn  --utt2spk=ark:data/train/split1/1/utt2spk scp:data/train/split1/1/cmvn.scp scp:data/train/split1/1/feats.scp ark:- | add-deltas ark:- ark:- | subset-feats --n=10 ark:- ark:-|' data/lang_train/topo 39 exp/mono/0.mdl exp/mono/tree 

apply-cmvn --utt2spk=ark:data/train/split1/1/utt2spk scp:data/train/split1/1/cmvn.scp scp:data/train/split1/1/feats.scp ark:- 
-aplikuje CMVN na všetky utt

add-deltas ark:- ark:- 
-pridá delda a delta-delta koeficienty

subset-feats --n=10 ark:- ark:- 
-kopíruje prvých 10 utt (MFCC matíc)

 	
-výpočet glob_inv_var a glob_mean (globálna hodnoda strednej hodnoty pre všetky matice MFCC a inverznej variancie so škálovaním 1/počet riadkov všetkých matíc: var_stats.Scale(1.0/count); mean_stats.Scale(1.0/count))

-nacitanie topológie zo súboru data/lang_train/topo
-príklad topológie
 <Topology>
 <TopologyEntry>
 <ForPhones> 1 2 3 4 5 6 7 8 </ForPhones>
 <State> 0 <PdfClass> 0
 <Transition> 0 0.5
 <Transition> 1 0.5
 </State> 
 <State> 1 <PdfClass> 1 
 <Transition> 1 0.5
 <Transition> 2 0.5
 </State>  
 <State> 2 <PdfClass> 2
 <Transition> 2 0.5
 <Transition> 3 0.5
 </State>   
 <State> 3
 </State>   
 </TopologyEntry>
 </Topology>

-vytvorí sa objekt triedy HmmTopology : this is the way the user specifies to the toolkit the topology of the HMMs the phones

HmmTopology topo;

extrahovanie foném typu int
const std::vector<int32> &phones = topo.GetPhones();	
phone[0]: 1
phone[1]: 2
…
phone[51]: 52

priradenie počtu pdf tried pre každú fonému
phone2num_pdf_classes[phones[i]] = topo.NumPdfClasses(phones[i]);
phone2num[1]: 5
phone2num[2]: 5
phone2num[3]: 5
phone2num[4]: 5
phone2num[5]: 5
phone2num[6]: 5
phone2num[7]: 3
...
phone2num[52]: 3
If the pdf-class for some HMM state is set to the constant kNoPdf = -1, then the HMM state is nonemitting (it has no associated pdf).
The set of pdf-classes for a particular prototype HMM is expected to start from zero and be contiguous (e.g. 0, 1, 2).
5 different pdf-ids. 





Vytvorenie stromu:

ContextDependency *ctx_dep = NULL;

-vytvorí sa smerník na objekt triedy ContexDependency

-následne načítanie phone listu:

ReadSharedPhonesList(shared_phones_rxfilename, &shared_phones);

shared_phones:[0][0]: 1
shared_phones:[1][0]: 2
shared_phones:[2][0]: 3
…
shared_phones:[51][0]: 52

-inicializácia:
 num_leaves = 0, P = 0, N = 1;


N is context size
P = position of central phone (must be 0)


typedef std::vector<std::pair<EventKeyType,EventValueType> > EventType; 

EvantMap trieda pre klastrovanie stromu:

EventMap *pdf_map = GetStubMap(P, phone_sets, phone2num_pdf_classes, share_roots, &num_leaves);

EventMap := ConstantEventMap | SplitEventMap | TableEventMap | "NULL"
ConstantEventMap := "CE" <numeric pdf-id>
SplitEventMap := "SE" <key-to-split-on> "[" yes-value-list "]" "{" EventMap EventMap "}"
TableEventMap := "TE" <key-to-split-on> <table-size> "(" EventMapList ")"

ContextDependency 1 0 ToPdf TE 0 53 ( NULL TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) 
TE -1 5 ( CE 5 CE 6 CE 7 CE 8 CE 9 ) 
TE -1 5 ( CE 10 CE 11 CE 12 CE 13 CE 14 ) 
TE -1 5 ( CE 15 CE 16 CE 17 CE 18 CE 19 ) 
TE -1 5 ( CE 20 CE 21 CE 22 CE 23 CE 24 ) 
TE -1 5 ( CE 25 CE 26 CE 27 CE 28 CE 29 ) 
TE -1 3 ( CE 30 CE 31 CE 32 ) 
…
TE -1 3 ( CE 165 CE 166 CE 167 ) 
) 
EndContextDependency 

“TE 0 53” the key "0" is the phone-position of zero which represents the central (and only) phone since the context width (N) is 1. The number of entries in the table is 53 (in this case, the number of phones plus one). The first EventMap in the table (index zero) is NULL, because there is no phone with index zero.

"TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )" represents splitting with a TableEventMap on the pdf-class "-1" (effectively, the HMM-position), and returning values 0 through 4. The values represent the five pdf-ids for the silence and noise phones SIL, NSN and SPN; in our setup, the pdfs are shared between these three non-speech phones (only the transition matrix is specific to each non-speech phone). Note: we have a 5-state rather than 3-state HMM for these phones, hence 
Inicializácia GMM

-pomocou objektov tried AmDiagGmm a DiagGmm

AmDiagGmm am_gmm;
DiagGmm gmm;
    gmm.Resize(1, dim);
    {  // Initialize the gmm.
-alokácia a inicializácia inv_var a mu pomocou vektorov globálnej strednej hodnoty a variancie

      Matrix<BaseFloat> inv_var(1, dim);
      inv_var.Row(0).CopyFromVec(glob_inv_var);
inv_var:  [ 0.012317 0.00639358 0.00683943 0.00435026 0.00755167 0.0054663 0.00601155 0.00632084 0.00547995 0.00777593 0.00802094 0.00596493 0.00901718 0.279607 0.147797 0.136844 0.100969 0.116538 0.0898784 0.107806 0.0918681 0.0799345 0.112086 0.111274 0.0945501 0.145626 1.91753 0.983717 0.865011 0.655235 0.670666 0.509123 0.605864 0.491665 0.443386 0.605588 0.60839 0.508616 0.787544 ]

	Matrix<BaseFloat> mu(1, dim);
      mu.Row(0).CopyFromVec(glob_mean);
mu:  [ -1.93785e-08 5.20363e-08 -2.03184e-09 7.16105e-08 2.64139e-08 -4.16317e-08 3.88169e-08 2.87818e-09 -4.31438e-08 -1.3298e-08 3.13304e-08 3.15461e-08 4.40389e-08 -0.000437066 0.0078276 0.00987549 0.00740368 0.00860737 -0.0005549 0.00432395 -0.00553214 -0.0123082 0.000648228 -0.00265132 0.000575265 -0.00190697 -0.000401413 0.0010554 -0.000208291 -0.00142547 0.00084816 0.00133549 0.000180131 0.00106665 -0.000806734 -0.00148568 0.000448892 -0.00038275 -0.000418162 ]
-alokácia a inicializácia váh weights na hodnotu 1

	Vector<BaseFloat> weights(1);
      weights.Set(1.0);

      gmm.SetInvVarsAndMeans(inv_var, mu);
-nainicializuje strednú hodnotu a varianciu pre všetky PDFs
dim=39; for (int i=0; i<dim; i++) inv_var[i] * mu[i]
<MEANS_INVVARS>  [
  -2.386852e-10 3.326984e-10 -1.389661e-11 3.115239e-10 1.994691e-10 -2.275714e-10 2.333496e-10 1.819253e-11 -2.364259e-10 -1.034045e-10 2.512991e-10 1.8817e-10 3.971067e-10 -0.0001222068 0.001156897 0.001351406 0.0007475433 0.001003082 -4.987351e-05 0.0004661482 -0.0005082276 -0.0009838532 7.265755e-05 -0.0002950226 5.439135e-05 -0.0002777049 -0.0007697208 0.001038217 -0.0001801743 -0.0009340189 0.0005688321 0.0006799264 0.0001091349 0.0005244361 -0.0003576949 -0.000899711 0.0002731017 -0.0001946728 -0.0003293207 ]

      gmm.SetWeights(weights);
-nastaví váhy na 1

      gmm.ComputeGconsts();
- precomputed constant terms in the likelihood
- equals log(weight) - 0.5 * (log det(var) + mean*mean*inv(var))


    }














Generovanie modelu prechodov
// Now the transition model:
  TransitionModel trans_model(*ctx_dep, topo);

 	ComputeTriples(ctx_dep);
- definuje trojicu čísel pre danú fonému, hmm stav a číslo PDF
- Triple(phone, hmm_state, pdf)

1 0 0 
1 1 1 
1 2 2 
1 3 3 
1 4 4 
2 0 5 
2 1 6 
2 2 7 
2 3 8 
2 4 9 
3 0 10 
3 1 11 
3 2 12 
3 3 13 
3 4 14 
4 0 15 
4 1 16 
4 2 17 
4 3 18 
4 4 19 
5 0 20 
5 1 21 
5 2 22 
5 3 23 
5 4 24 
6 0 25 
6 1 26 
6 2 27 
6 3 28 
6 4 29 
7 0 30 
7 1 31 
7 2 32 
8 0 33 
8 1 34 
8 2 35 
…
52 0 165 
52 1 166 
52 2 167 

	ComputeDerived();
-na základe inicializačnej topológie (topo) a trojice (fonéma, hmm stav, pdf id) definuje počet prechodov

phone:1 hmm_state:0 pdf:0 num_transitions[1]:4
cur_transition_id[1]5
phone:1 hmm_state:1 pdf:1 num_transitions[2]:4
cur_transition_id[2]9
phone:1 hmm_state:2 pdf:2 num_transitions[3]:4
cur_transition_id[3]13
phone:1 hmm_state:3 pdf:3 num_transitions[4]:4
cur_transition_id[4]17
phone:1 hmm_state:4 pdf:4 num_transitions[5]:2
cur_transition_id[5]19
phone:2 hmm_state:0 pdf:5 num_transitions[6]:4
cur_transition_id[6]23
phone:2 hmm_state:1 pdf:6 num_transitions[7]:4
cur_transition_id[7]27
phone:2 hmm_state:2 pdf:7 num_transitions[8]:4
cur_transition_id[8]31
phone:2 hmm_state:3 pdf:8 num_transitions[9]:4
cur_transition_id[9]35
phone:2 hmm_state:4 pdf:9 num_transitions[10]:2
cur_transition_id[10]37
…
phone:52 hmm_state:0 pdf:165 num_transitions[166]:2
cur_transition_id[166]381
phone:52 hmm_state:1 pdf:166 num_transitions[167]:2
cur_transition_id[167]383
phone:52 hmm_state:2 pdf:167 num_transitions[168]:2
cur_transition_id[168]385

	InitializeProbs();
-nainicializuje pole prob na hodhoty pravdepodobností prechodov medzi stavmi podľa topo
prob[1]: 0.25
prob[2]: 0.25
prob[3]: 0.25
prob[4]: 0.25
prob[5]: 0.25
prob[6]: 0.25
prob[7]: 0.25
prob[8]: 0.25
prob[9]: 0.25
prob[10]: 0.25
prob[11]: 0.25
prob[12]: 0.25
prob[13]: 0.25
prob[14]: 0.25
prob[15]: 0.25
prob[16]: 0.25
prob[17]: 0.75
…
prob[380]: 0.25
prob[381]: 0.75
prob[382]: 0.25
prob[383]: 0.75
prob[384]: 0.25

-následne sa vypočíta logaritmus Log(prob)

	Check();

####################################################################
-spustenie compile-train-graphs
####################################################################
-vytvorí graf

compile-train-graphs exp/mono/tree exp/mono/0.mdl data/lang_train/L.fst 'ark:sym2int.pl --map-oov 1 -f 2- data/lang_train/words.txt < data/train/split1/1/text|' 'ark:|gzip -c >exp/mono/fsts.1.gz' 

-extrahuje utterances a prepisy zo slovníka

std::vector<std::string> keys;
std::vector<std::vector<int32> > transcripts;

speaker000-par001s0030
45332 30302 14214 36179 42862 117 20427 19022 27848 54 54 250 3575 34527 3574 16205 
speaker001-par004s0011
54 43790 25015 36917 18278 54 
speaker002-par007s0008
54 2176 11010 22250 45332 34007 41461 24041 39841 16432 
speaker003-par010s0006
36179 21162 28166 18369 54 27621 57 24103 45422 
speaker004-par013s0002
8964 11537 12910 7806 18369 30863 31307 54 57 43237 36584 17882 33312 
speaker005-par016s0011
24426 34928 6725 54 479 
speaker006-par019s0013
8348 34719 28097 25241 39285 6623 
speaker007-par022s0004
54 43617 39285 18131 28441 31255 28936 39285 18131 28441 31255 28936 24819 5968 29766 57 12056 54 
speaker008-par025s0003
54 54 39105 9262 9257 54 23216 39090 117 32632 23695 40764 12239 36179 29366 33373 
speaker009-par028s0009
39108 28097 25241 18131 28441 31255 28936 





6. Trénovanie trifónového GMM/HMM modelu

